import Data.Char
import Data.List
{-
Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
изучите примеры из лекции по функциям высшего порядка. 
-}


{-
 1. Простейшие задачи на применение функций map и filter.
 1.1 Преобразовать данный целых чисел следующим образом:
  a) увеличить все его элементы в два раза;
  b) увеличить все его элементы с четными значениями в два раза;
  с) обнулить все его элементы с нечетными значениями;
  d) удалить из него элементы, большие заданного числа k;
  e) отфильтровать его, оставив в списке только отрицательные числа;
  f) удалить из него все положительные чётные числа.
-}

f11a :: Integral a => [a] -> [a]
f11a  a = map (*2) a

f11b :: Integral a => [a] -> [a]
f11b  a = map (*2) (filter even a)

f11c  a = map (\x -> if odd x then 0 else x) a


f11d  a k = filter (<k) a


f11e  a= filter (<0) a

f11ft a = f11e (filter odd a)

f11f  a = filter(\x -> odd x && x>0 || x<0) a


{-
 1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
     Преобразовать его следующим образом:
  a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
  b) преобразовать декартовы координаты в полярные.
-}

fil a 1 =  filter(\x -> fst x >0 && snd x >0 ) a
fil a 2 =  filter(\x -> fst x >0 && snd x <0 ) a
fil a 3 =  filter(\x -> fst x <0 && snd x <0 ) a
fil a 4 =  filter(\x -> fst x <0 && snd x >0 ) a
{-
 1.3 Дан список слов.
  a) Преобразовать все слова к верхнему регистру.
  b) Извлечь из него подсписок слов заданной длины.
  c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
-}
f13a :: [String] -> [String]
f13a a =  map (map toUpper) a

f13b a =  filter (\x -> (length x) <10) a 

f13c a =  filter (\x -> aasa 'a' x) a 



aasa _ [] = False
aasa p (x:xs)
  |p== x = True
  |otherwise = False


{-
2. Формирование числовых последовательностей (iterate).
 a) Список натуральных чисел, начиная с 0.
 b) Список чётных чисел.
 c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
 d) Список символов английского алфавита.
 e) Список строк, представляющих n-значные двоичные числа.
-}


nats = take 6 $ iterate (+1) 1

task_b n =take n $  filter ((==0).(`mod` 2)) $ iterate (+1) 1

task_c n = take n (iterate (\x -> (1 + x)/2) 1) 

task_d = take 24 (iterate (\x -> succ x) 'a')





{-
3. Группировка списков.
  a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
  b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
     координаты точек, лежащие в одной координатной четверти.
  c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
     Последний подсписок может содержать менее n элементов.
  d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
     длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
  e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.
-}

f3a = groupBy(\a b -> isDigit a == isDigit b) 

f3b = groupBy(\(a,b) (c,d) -> a >0 && b >0 && c>0 &&d >0) 


--f3d :: [a] -> Int -> Int -> [[a]]
--f3d xs n m = undefined
f3c _ [] = []
f3c n xs = (take n xs) : f3c n (drop n (xs))

f3d _ _ [] = []
f3d n m xs = (take n xs): f3d n m (drop m (xs)) 


-- Должно быть True
test_f3d = f3d 4 2 [1..10] == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

{-
4. Разные задачи.
 a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
    всех упоминающихся в тексте чисел.

 b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
    (например: все чётные от 1 до 106).
 c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
    в строке символов.
 d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
    называется элемент, больший своих соседей.
 e) Дан список. Продублировать все его элементы.
-}




task_4_1_ [] _ = 0
task_4_1_ (x:xs) p
  |isDigit x && not (isDigit p) = 1+ task_4_1_ xs x
  |otherwise = task_4_1_ xs x

task_4_1 list = task_4_1_ list 'a'


fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
task_4_2 = takeWhile(<106) (filter even fibs)


task_4_d [] = []
task_4_d (b:c:[])
  |c>b = c:task_4_d []
  |otherwise = task_4_d []



task_4_d (a:b:c:xs)
  |b>a && b>c = b:task_4_d (b:c:xs)
  |otherwise =task_4_d (b:c:xs)



task_4_e [] = []
task_4_e (x:xs) = x:x:task_4_e (xs)



